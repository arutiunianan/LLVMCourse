; Входные параметры: 
; R0 - x-координата (i32)
; R1 - y-координата (i32)
; R2 - указатель на массив (ptr)

countLivingNeighbors:
    ; Инициализация
    MOV R3, R0         ; x = %0
    MOV R4, R1         ; y = %1
    MOV R5, 0          ; living_neighbors = 0

    ; Проверка границ
    ADD R6, R3, -1      ; x - 1
    CMP R6, 511
    JG check_y_bounds   ; если x > 511, переходим к проверке y

check_x_bounds:
    CMP R4, 255
    JG check_next_x     ; если y > 255, переходим к следующему x

    ; Проверка живых соседей
    SHL R7, R4, 9      ; y * 512
    OR R8, R7, R3      ; index = (y * 512) + x
    MOV R9, [R2 + R8]  ; load value from array
    CMP R9, 0
    JE no_neighbor      ; если значение равно 0, нет соседа

    INC R5              ; увеличиваем счетчик живых соседей

no_neighbor:
    INC R4              ; y++
    JMP check_x_bounds   ; повторяем проверку для следующего y

check_next_x:
    INC R3              ; x++
    CMP R3, 512
    JG done             ; если x > 511, завершаем

    MOV R4, 0          ; сбрасываем y
    JMP check_x_bounds

done:
    RRET R5             ; возвращаем количество живых соседей


; Входные параметры:
; R0 - x-координата (i32)
; R1 - y-координата (i32)
; R2 - указатель на массив (ptr)
; R3 - указатель на выходной массив (ptr)

updatePixel:
    ; Считаем количество живых соседей
    MOV R4, R0                ; x = %0
    MOV R5, R1                ; y = %1
    CALL countLivingNeighbors  ; %5 = countLivingNeighbors(x, y, ptr)

    ; Вычисляем индекс в массиве
    SHL R6, R5, 9             ; %6 = y << 9 (умножаем на 512)
    ADD R7, R6, R4            ; %7 = %6 + x
    EXT64 R8, R7                ; %8 = (i64)%7 (расширяем до 64 бит)

    ; Загружаем значение из массива
    MOV R9, [R2 + R8]         ; %10 = load value from array

    ; Проверяем состояние пикселя
    CMP R9, 1                 ; %11 = (значение == 1)
    AND R10, R4, -2           ; %12 = %5 & -2
    CMP R10, 2                ; %13 = (%12 == 2)
    CMP R4, 3                 ; %14 = (%5 == 3)

    ; Определяем новое состояние пикселя
    SELECT R15, R11, R13, R14 ; %15 = select(%11, %13, %14)
    EXT64 R16, R15               ; %16 = zext %15 to i32

    ; Сохраняем новое значение в выходном массиве
    MOV R17, [R3 + R8]        ; %17 = getelementptr inbounds
    STORE R16, [R17]          ; store %16 to ptr

    RET                        ; Возвращаем управление


; Входные параметры:
; R0 - указатель на первый пиксель (ptr)
; R1 - указатель на второй пиксель (ptr)

swapPixels:
    ; Загружаем значения из указателей
    MOV R2, [R0]              ; %3 = load ptr from %0
    MOV R3, [R1]              ; %4 = load ptr from %1

    ; Меняем местами значения
    STORE R3, [R0]            ; store %4 to %0
    STORE R2, [R1]            ; store %3 to %1

    RET                        ; Возвращаем управление


; Входные параметры:
; R0 - указатель на массив 1 (ptr)
; R1 - указатель на массив 2 (ptr)

gameOfLife:
    ; Начальная метка
    JMP label_3

label_3:
    ; Инициализация указателей
    MOV R4, R0                ; %4 = %0
    MOV R5, R1                ; %5 = %1
    JMP label_6

label_6:
    ; Инициализация индекса
    MOV R7, 0                  ; %7 = 0
    JMP label_13

label_9:
    ; Вызов функции simFlush
    CALL simFlush           ; Обновление экрана
    JMP label_3                ; Возврат к началу

label_10:
    ; Увеличение индекса
    INC R7                     ; %11 = %7 + 1
    CMP R7, 512                ; Проверка условия выхода
    JE label_9                 ; Если равно 512, перейти к label_9
    JMP label_6                ; Иначе продолжить цикл

label_13:
    ; Основная логика обработки пикселей
    SHL R15, R7, 9             ; %15 = %7 << 9 (умножаем на 512)
    ADD R16, R4, R15           ; %16 = %4 + %15 (адрес пикселя)
    LOAD R17, [R16]            ; Загрузка значения пикселя
    CMP R17, 0                 ; Проверка состояния пикселя
    JE color_black             ; Если мертвый, установить черный цвет
    MOV R20, 16711680          ; Установить цвет красный
    JMP process_pixel

color_black:
    MOV R20, -16777216         ; Установить цвет черный

process_pixel:
    EXT32 R8, R7               ; Приведение типа индекса
    CALL simPutPixel, R8, R21, R20 ; Обновление цвета пикселя

    ; Подсчет живых соседей
    CALL countLivingNeighbors, R8, R21, R4 ; Получение количества живых соседей

    LOAD R23, [R16]            ; Загрузка текущего состояния пикселя
    CMP R23, 1                 ; Проверка состояния
    AND R22, R22, -2           ; Логическая операция для определения состояния

    ; Определение нового состояния пикселя
    CMP R22, 2                 ; Проверка на количество живых соседей
    JE set_new_state           ; Если 2 живых соседа
    CMP R22, 3                 ; Проверка на количество живых соседей
    JE set_new_state           ; Если 3 живых соседа

set_new_state:
    STORE R29, [R30]           ; Сохранение нового состояния в выходном массиве

    INC R14                    ; Увеличение индекса
    CMP R14, 256               ; Проверка условия выхода
    JE label_10                ; Если равно 256, перейти к label_10
    JMP label_13               ; Иначе продолжить цикл


; Входные параметры:
; R0 - указатель на первый массив (ptr)
; R1 - указатель на второй массив (ptr)

app:
    ; Инициализация первого массива нулями
    MOV R2, 0                 ; Значение для инициализации
    MOV R3, 524288            ; Размер массива (512 * 256)

init_loop_1:
    CMP R3, 0                 ; Проверка: достигли ли конца массива?
    JLE end_init_loop_1       ; Если да, выходим из цикла

    STORE R2, [R0]            ; Сохраняем 0 в текущую ячейку первого массива
    ADD R0, R0, 4             ; Переходим к следующему элементу (i32 = 4 байта)
    DEC R3                     ; Уменьшаем счетчик
    JMP init_loop_1           ; Повторяем цикл

end_init_loop_1:
    ; Инициализация второго массива нулями
    MOV R2, 0                 ; Значение для инициализации
    MOV R3, 524288            ; Размер массива (512 * 256)

init_loop_2:
    CMP R3, 0                 ; Проверка: достигли ли конца массива?
    JLE end_init_loop_2       ; Если да, выходим из цикла

    STORE R2, [R1]            ; Сохраняем 0 в текущую ячейку второго массива
    ADD R1, R1, 4             ; Переходим к следующему элементу (i32 = 4 байта)
    DEC R3                     ; Уменьшаем счетчик
    JMP init_loop_2           ; Повторяем цикл

end_init_loop_2:
    MOV R4, 0                 ; Внешний индекс (по строкам)

outer_loop:
    CMP R4, 512               ; Проверка: достигли ли конца по строкам?
    JGE end_outer_loop        ; Если да, выходим из внешнего цикла

    MOV R5, 0                 ; Внутренний индекс (по столбцам)

inner_loop:
    CMP R5, 256               ; Проверка: достигли ли конца по столбцам?
    JGE end_inner_loop        ; Если да, выходим из внутреннего цикла

    CALL simRand              ; Генерируем случайное число
    MOV R6, RAX               ; Сохраняем его в R6

    ; Вычисляем индекс в массиве
    SHL R7, R4, 9             ; %7 = y << 9 (умножаем на 512)
    ADD R8, R7, R5            ; %8 = %7 + x
    EXT64 R9, R8                ; %9 = (i64)%8 (расширяем до 64 бит)

    ; Сохраняем значение в первом массиве
    STORE R6, [R0 + R9]      ; Сохраняем значение в первом массиве

    ; Сохраняем значение во втором массиве
    STORE R6, [R1 + R9]      ; Сохраняем значение во втором массиве

    INC R5                    ; Увеличиваем внутренний индекс
    JMP inner_loop            ; Переход к проверке конца внутреннего цикла

end_inner_loop:
    INC R4                    ; Увеличиваем внешний индекс
    JMP outer_loop            ; Переход к проверке конца внешнего цикла

end_outer_loop:
    RET                       ; Завершение функции

